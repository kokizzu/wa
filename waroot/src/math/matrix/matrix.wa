// Copyright (C) 2024 武汉凹语言科技有限公司
// SPDX-License-Identifier: MIT

import "math"
import "math/vector"

type Mat4f :struct {
	M: [4][4]f32
}

func Mat4f.Identity() {
	this.M[0][0] = 1
	this.M[0][1] = 0
	this.M[0][2] = 0
	this.M[0][3] = 0
	this.M[1][0] = 0
	this.M[1][1] = 1
	this.M[1][2] = 0
	this.M[1][3] = 0
	this.M[2][0] = 0
	this.M[2][1] = 0
	this.M[2][2] = 1
	this.M[2][3] = 0
	this.M[3][0] = 0
	this.M[3][1] = 0
	this.M[3][2] = 0
	this.M[3][3] = 1
}

func NewPerspective(fov, aspect, n, f: f32) => Mat4f {
	m: Mat4f
	sin := math.Sin(fov / 2.0)
	cos := math.Cos(fov / 2.0)
	y := 1.0 / (sin / cos)
	x := y / aspect

	m.M[0][0] = x
	m.M[0][1] = 0
	m.M[0][2] = 0
	m.M[0][3] = 0
	m.M[1][0] = 0
	m.M[1][1] = y
	m.M[1][2] = 0
	m.M[1][3] = 0
	m.M[2][0] = 0
	m.M[2][1] = 0
	m.M[2][2] = f / (n - f)
	m.M[2][3] = -1
	m.M[3][0] = 0
	m.M[3][1] = 0
	m.M[3][2] = n * f / (n - f)
	m.M[3][3] = 0

	return m
}

func NewRotateAxis(axis: vector.Vec3f, angle: f32) => Mat4f {
	m: Mat4f

	axis = vector.Normalize(axis)
	sinv := math.Sin(angle)
	cosv := math.Cos(angle)
	m.M[0][0] = axis.X*axis.X*(1-cosv) + cosv
	m.M[0][1] = axis.Y*axis.X*(1-cosv) + axis.Z*sinv
	m.M[0][2] = axis.Z*axis.X*(1-cosv) - axis.Y*sinv
	m.M[1][0] = axis.X*axis.Y*(1-cosv) - axis.Z*sinv
	m.M[1][1] = axis.Y*axis.Y*(1-cosv) + cosv
	m.M[1][2] = axis.Z*axis.Y*(1-cosv) + axis.X*sinv
	m.M[2][0] = axis.X*axis.Z*(1-cosv) + axis.Y*sinv
	m.M[2][1] = axis.Y*axis.Z*(1-cosv) - axis.X*sinv
	m.M[2][2] = axis.Z*axis.Z*(1-cosv) + cosv
	m.M[3][3] = 1

	return m
}

func NewTranslate(v: vector.Vec3f) => Mat4f {
	m: Mat4f
	m.M[0][0] = 1
	m.M[1][1] = 1
	m.M[2][2] = 1
	m.M[3][3] = 1
	m.M[3][0] = v.X
	m.M[3][1] = v.Y
	m.M[3][2] = v.Z

	return m
}

func NewCameraTransform(cam, view, up: vector.Vec3f) => Mat4f {
	za := vector.Normalize(vector.Sub(cam, view))
	xa := vector.Normalize(vector.CrossProduct(up, za))
	ya := vector.CrossProduct(za, xa)

	m: Mat4f
	m.M[0][0] = xa.X
	m.M[0][1] = ya.X
	m.M[0][2] = za.X
	m.M[0][3] = 0
	m.M[1][0] = xa.Y
	m.M[1][1] = ya.Y
	m.M[1][2] = za.Y
	m.M[1][3] = 0
	m.M[2][0] = xa.Z
	m.M[2][1] = ya.Z
	m.M[2][2] = za.Z
	m.M[2][3] = 0
	m.M[3][0] = -1 * vector.DotProduct(xa, cam)
	m.M[3][1] = -1 * vector.DotProduct(ya, cam)
	m.M[3][2] = -1 * vector.DotProduct(za, cam)
	m.M[3][3] = 1

	return m
}

func Mul(a, b: Mat4f) => Mat4f {
	t: Mat4f
	t.M[0][0] = a.M[0][0]*b.M[0][0] + a.M[0][1]*b.M[1][0] + a.M[0][2]*b.M[2][0] + a.M[0][3]*b.M[3][0]
	t.M[0][1] = a.M[0][0]*b.M[0][1] + a.M[0][1]*b.M[1][1] + a.M[0][2]*b.M[2][1] + a.M[0][3]*b.M[3][1]
	t.M[0][2] = a.M[0][0]*b.M[0][2] + a.M[0][1]*b.M[1][2] + a.M[0][2]*b.M[2][2] + a.M[0][3]*b.M[3][2]
	t.M[0][3] = a.M[0][0]*b.M[0][3] + a.M[0][1]*b.M[1][3] + a.M[0][2]*b.M[2][3] + a.M[0][3]*b.M[3][3]

	t.M[1][0] = a.M[1][0]*b.M[0][0] + a.M[1][1]*b.M[1][0] + a.M[1][2]*b.M[2][0] + a.M[1][3]*b.M[3][0]
	t.M[1][1] = a.M[1][0]*b.M[0][1] + a.M[1][1]*b.M[1][1] + a.M[1][2]*b.M[2][1] + a.M[1][3]*b.M[3][1]
	t.M[1][2] = a.M[1][0]*b.M[0][2] + a.M[1][1]*b.M[1][2] + a.M[1][2]*b.M[2][2] + a.M[1][3]*b.M[3][2]
	t.M[1][3] = a.M[1][0]*b.M[0][3] + a.M[1][1]*b.M[1][3] + a.M[1][2]*b.M[2][3] + a.M[1][3]*b.M[3][3]

	t.M[2][0] = a.M[2][0]*b.M[0][0] + a.M[2][1]*b.M[1][0] + a.M[2][2]*b.M[2][0] + a.M[2][3]*b.M[3][0]
	t.M[2][1] = a.M[2][0]*b.M[0][1] + a.M[2][1]*b.M[1][1] + a.M[2][2]*b.M[2][1] + a.M[2][3]*b.M[3][1]
	t.M[2][2] = a.M[2][0]*b.M[0][2] + a.M[2][1]*b.M[1][2] + a.M[2][2]*b.M[2][2] + a.M[2][3]*b.M[3][2]
	t.M[2][3] = a.M[2][0]*b.M[0][3] + a.M[2][1]*b.M[1][3] + a.M[2][2]*b.M[2][3] + a.M[2][3]*b.M[3][3]

	t.M[3][0] = a.M[3][0]*b.M[0][0] + a.M[3][1]*b.M[1][0] + a.M[3][2]*b.M[2][0] + a.M[3][3]*b.M[3][0]
	t.M[3][1] = a.M[3][0]*b.M[0][1] + a.M[3][1]*b.M[1][1] + a.M[3][2]*b.M[2][1] + a.M[3][3]*b.M[3][1]
	t.M[3][2] = a.M[3][0]*b.M[0][2] + a.M[3][1]*b.M[1][2] + a.M[3][2]*b.M[2][2] + a.M[3][3]*b.M[3][2]
	t.M[3][3] = a.M[3][0]*b.M[0][3] + a.M[3][1]*b.M[1][3] + a.M[3][2]*b.M[2][3] + a.M[3][3]*b.M[3][3]

	return t
}
