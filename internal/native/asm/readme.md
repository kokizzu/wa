# Wa Native 汇编语言

主要是内部用于表示 RISCV 等本地的汇编语言程序.

## 注释

- 支持 `#` 开头的单行注释

## 语句

- 语句以分号分割
- 每个换行符号可能会自动插入分号
- 同一个指令不会跨越多行

## 名字

- 关键字为小写字母, 比如 `func` 表示定义函数, `global` 表示定义全局变量
- 全局标识符以 `$` 开头, 比如 `$main` 表示 main 函数
- 局部标识符以 `%` 开头, 比如 `%a` 表示局部变量名
- 指令不区分大小写, 比如 `CALL` 和 `call` 等价
- 寄存器不区分大小写, 比如 `PC` 和 `pc` 等价
- `_.$`和字母数字都是合法的字符

## 关键字

- `i32`: `int32`
- `i64`: `int64`
- `u32`: `uint32`
- `u64`: `uint64`
- `f32`: `float32`
- `f64`: `float63`
- `ptr`: uint pointer
- `const`: 定义全局常量
- `global`: 定义全局变量
- `local`: 定义局部变量
- `func`: 定义函数
- 寄存器: 平台相关定义
- 指令: 平台相关定义

## 关键字(中文)

```go
	I32_zh    // 整32
	I64_zh    // 整64
	U32_zh    // 无整32
	U64_zh    // 无整64
	F32_zh    // 浮32
	F64_zh    // 浮64
	PTR_zh    // 指针
	CONST_zh  // 常量
	GLOBAL_zh // 全局
	LOCAL_zh  // 局部
	FUNC_zh   // 函数
```

## 字面值

- 默认整数类型: `123` 为 `i32`
- 默认浮点数类型: `12.3` 为 `f32`
- 不支持表达式: 不支持 `1+2` 写法
- 字符常量: `'A'`/`'1'`, 为 `i32` 对应字符的码点值
- 整数常量: `123`, 数字部分支持二进制/十进制/十六进制等
- 浮点数常量: `1.5`/`123.456`, 数字部分支持普通浮点数/科学计数法/十六进制等
- 字符串常量: 支持单行字符串, 转义规则参考凹语言
- 地址常量: 标识符表示的地址, `ptr` 类型

## 全局常量

常量和面值一样有类型(整数/浮点数/地址), 目的是为了更精确记录原始的字面值. 常量的值不支持运算表达式, 也不支持引用其他标识符.

```go
# 默认常量类型
const $A = 'A' # i32
const $B = 123 # i32
const $C = 1.5 # f32

# 指定常量类型
const $D = i64('D') # i64
const $E = f64(456) # f64, 接受 int 和 float
const $F = f64(1.5)

# 无符号类型
const $H = u32(0xABCD) # u32
const $I = u64(0xABCD) # u64

# 地址类型
const $P = ptr(0xABCD) # ptr, 只接受正整数

# 字符串
const $S = "abcd" # STRING

# 错误的用法
# const $A = 1+2
# const $B = $A
```

## 全局变量

- 变量只是一段内存, 只有内存大小, 没有类型
- 但常量的初始化值有类型

```go
# 默认的i32
global $age: i32 = 5
global $ch: i32 = 'A'

# 默认的f32
global $size: f32 = 12.3

# 整数, 4字节, 12345678 
global $i32: i32 = 12345678

# 整数, 8字节, 0x12345678
global $i64: i64 = 0x12345678

# float32
global $f32: f32 = 12.5

# float64
global $f64: f64 = 12.34567

# utf8 编码的字符串, 结尾自动添加 `\0`, 地址和长度自动对齐到 8 字节
global $name = "wa native assembly language"
```

全局变量可以指定更大的长度:

```go
global $f32: 20 = f32(12.5)

# 指定长度的字符串, 不足部分补充0
global $str: 100 = "abc"
```

分段初始化(类似结构体):

```go
# 1024 字节结构体
# pos: value, 只能是用基础常量面值初始化
global $info: 1024 = {
    5: "abc",    # 从第5字节开始 `abc\0`
    9: i32(123), # 从第9字节开始
}
```

用常量初始化:

```go
global $ptr = $UART0 # 常量没有地址
```

用`$info`地址初始化:

```go
global $ptr = $info # $info 的地址
```

## 函数和寄存器

- `SB`: 数据段的开始位置, 用于全局变量定位
- `PC`: 当前指令位置, 用于 Label 等局部定位
- `FP`: 函数帧指针, 用于参数/返回值/局部变量定位
- `SP`: 函数栈指针, 用于临时变量, 调用参数等

定义函数:

```go
# 参数和返回值根据调用约定对齐
# 参数和返回值只支持基础的数据类型, 不支持结构体和数组值传入
func $add(%a:i32, %b:i32, %c:i32) => f64 {
    local %d: i32 # 局部变量必须先声明, i32 大小的空间

    # 指令
Loop:
}
```

## 地址表达式

- `MOVQ X1, $info   # X0 = $info`, 加载全局地址
- `MOVQ X1, $info+2 # X0 = $info`, 加载全局地址, 加偏移量
- `MOVQ %e, X1      # e[0] = X1`, 局部变量地址
- `MOVQ %e+10, X1   # e[9] = X1`, 局部变量地址, 加偏移量
- `MOVQ X2, Loop`, 局部标号

## 指令格式

- `ADD X1, X2, X3 # X1 = X2 + X3`

## 例子(中文版)

QEMU 裸机输出字符串的例子:

```go
# 兼容 QEMU virt 机器的 串口 和 关机 设备地址
常量 $串口 = 0x10000000
常量 $关机 = 0x100000

# 用于输出的字符串
全局 $信札 = "你好, 睿斯克发威 裸金属(RISC-V Baremetal)!\n\x00"

# 主函数
函数 _启动 {
%开篇:
    # 参甲格 = 字符串地址
    auipc   参甲格, %相对高位($信札)         # 高20位 = 当前PC + 偏移
    addi    参甲格, 参甲格, %相对低位(%开篇)  # 低12位

%精卫填海:
    lbu  参乙格, 0(参甲格)   # 取一个字节
    beq  参乙格, 零格, %收工 # 如果是0则结束

    # 暂甲格 = 串口 地址
    lui     暂甲格, %高位($串口)           # 串口 高20位
    addi    暂甲格, 暂甲格, %低位($串口)   # 串口 低12位

    sb   参乙格, 0(暂甲格)        # 写到 串口 寄存器
    addi 参甲格, 参甲格, 1        # 下一个字符
    jal  零格, %精卫填海

%收工:
    # 写退出码 0 到 关机 寄存器, 退出模拟器
    lui     暂甲格, %高位($关机)     # 关机寄存器地址
    addi    暂甲格, 暂甲格, %低位($关机)

    # 暂乙格 = 0x5555
    lui   暂乙格, 0x5             # 高 20 位 (0x5 << 12 = 0x5000)
    addi  暂乙格, 暂乙格, 0x555   # 结果 = 0x5000 + 0x555 = 0x5555

    sw   暂乙格, 0(暂甲格)

    # 如果不支持 关机设备，就进入 苦海无边 死循环
%苦海:
    jal 零格, %苦海
}
```
