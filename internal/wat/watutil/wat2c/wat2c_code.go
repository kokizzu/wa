// 版权 @2024 凹语言 作者。保留所有权利。

package wat2c

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"strings"

	"wa-lang.org/wa/internal/wat/token"
)

//go:embed _math_x.c
var math_x_code string

func (p *wat2cWorker) buildCode(w io.Writer) error {
	fmt.Fprintf(w, "// Auto Generated by https://wa-lang.org/wa/wat2c. DONOT EDIT!!!\n\n")

	if p.m.Name != "" {
		fmt.Fprintf(w, "// module %s\n\n", p.m.Name)
	}

	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintf(w, "#include <stdlib.h>\n")
	fmt.Fprintf(w, "#include <stdio.h>\n")
	fmt.Fprintf(w, "#include <string.h>\n")
	fmt.Fprintf(w, "#include <math.h>\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "typedef uint8_t   u8_t;\n")
	fmt.Fprintf(w, "typedef int8_t    i8_t;\n")
	fmt.Fprintf(w, "typedef uint16_t  u16_t;\n")
	fmt.Fprintf(w, "typedef int16_t   i16_t;\n")
	fmt.Fprintf(w, "typedef uint32_t  u32_t;\n")
	fmt.Fprintf(w, "typedef int32_t   i32_t;\n")
	fmt.Fprintf(w, "typedef uint64_t  u64_t;\n")
	fmt.Fprintf(w, "typedef int64_t   i64_t;\n")
	fmt.Fprintf(w, "typedef float     f32_t;\n")
	fmt.Fprintf(w, "typedef double    f64_t;\n")
	fmt.Fprintf(w, "typedef uintptr_t ref_t;\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "typedef union val_t {\n")
	fmt.Fprintf(w, "  i64_t i64;\n")
	fmt.Fprintf(w, "  f64_t f64;\n")
	fmt.Fprintf(w, "  i32_t i32;\n")
	fmt.Fprintf(w, "  f32_t f32;\n")
	fmt.Fprintf(w, "  ref_t ref;\n")
	fmt.Fprintf(w, "} val_t;\n\n")

	fmt.Fprintf(w, `#ifdef NDEBUG`+"\n")
	fmt.Fprintf(w, `  #define WASM_TRACE() ((void)0)`+"\n")
	fmt.Fprintf(w, `#else`+"\n")
	fmt.Fprintf(w, `  #define WASM_TRACE() printf("%%s %%s:%%d\n",__FUNCTION__,__FILE__,__LINE__)`+"\n")
	fmt.Fprintf(w, `#endif`+"\n")
	fmt.Fprintln(w)

	if err := p.buildImport(w); err != nil {
		return err
	}

	if err := p.buildMemory(w); err != nil {
		return err
	}
	if err := p.buildTable(w); err != nil {
		return err
	}

	if err := p.buildGlobal(w); err != nil {
		return err
	}
	if err := p.buildFuncs(w); err != nil {
		return err
	}

	if err := p.buildTable_elem(w); err != nil {
		return err
	}
	if err := p.buildMemory_data(w); err != nil {
		return err
	}

	// 生成main函数
	for _, f := range p.m.Funcs {
		if f.Name == "_main" {
			fmt.Fprintln(w)
			fmt.Fprintf(w, "int main() {\n")
			fmt.Fprintf(w, "  fn_memory_init();\n")
			fmt.Fprintf(w, "  fn_table_init();\n")
			fmt.Fprintf(w, "  fn_%s();\n", toCName("_start"))
			fmt.Fprintf(w, "  fn_%s();\n", toCName(f.Name))
			fmt.Fprintf(w, "  return 0;\n")
			fmt.Fprintf(w, "}\n")
			break
		}
	}

	return nil
}

func (p *wat2cWorker) buildImport(w io.Writer) error {
	if len(p.m.Imports) == 0 {
		return nil
	}

	// 同一个函数可能被导入多次
	var hostFuncMap = make(map[string]bool)

	// 声明原始的宿主函数
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.FUNC {
			continue
		}

		fnName := importSpec.ObjModule + "." + importSpec.ObjName
		fnType := importSpec.FuncType

		// 已经处理过
		if hostFuncMap[fnName] {
			continue
		}
		hostFuncMap[fnName] = true

		// 返回值类型
		cRetType := p.getHostFuncCRetType(fnType, fnName)
		if len(fnType.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(fnType.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch fnType.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "i32_t $R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "i64_t $R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "f32_t $R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "f64_t $R%d;", i)
				default:
					unreachable()
				}
			}
			fmt.Fprintf(w, "} host_fn_%s_ret_t;\n", toCName(fnName))
		}

		// 返回值通过栈传递
		fmt.Fprintf(w, "extern %s host_fn_%s(", cRetType, toCName(fnName))
		if len(fnType.Params) > 0 {
			for i, x := range fnType.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("$arg%d", i)
				}
				if i > 0 {
					fmt.Fprint(w, ", ")
				}

				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "i32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "i64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "f32_t %v", argName)
				case token.F64:
					fmt.Fprintf(w, "f64_t %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	// 声明导入后的函数
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.FUNC {
			continue
		}

		fnName := importSpec.FuncName
		fnType := importSpec.FuncType

		fmt.Fprintf(w, "// import %s.%s\n",
			importSpec.ObjModule, importSpec.ObjName,
		)

		// 返回值类型
		cRetType := p.getFuncCRetType(fnType, fnName)
		if len(fnType.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(fnType.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch fnType.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "i32_t $R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "i64_t $R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "f32_t $R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "f64_t $R%d;", i)
				default:
					unreachable()
				}
			}
			fmt.Fprintf(w, "} fn_%s_ret_t;\n", toCName(fnName))
		}

		// 返回值通过栈传递
		fmt.Fprintf(w, "static %s fn_%s(", cRetType, toCName(fnName))
		if len(fnType.Params) > 0 {
			for i, x := range fnType.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("$arg%d", i)
				}
				if i > 0 {
					fmt.Fprint(w, ", ")
				}

				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "i32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "i64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "f32_t %v", argName)
				case token.F64:
					fmt.Fprintf(w, "f64_t %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	// 定义导入后的函数
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.FUNC {
			continue
		}

		fnName := importSpec.FuncName
		fnType := importSpec.FuncType

		fmt.Fprintf(w, "// import %s.%s\n",
			importSpec.ObjModule, importSpec.ObjName,
		)

		// 返回值类型
		cHostRetType := p.getFuncCRetType(fnType, importSpec.ObjModule+"."+importSpec.ObjName)
		cRetType := p.getFuncCRetType(fnType, fnName)

		// 返回值通过栈传递
		fmt.Fprintf(w, "static %s fn_%s(", cRetType, toCName(fnName))
		if len(fnType.Params) > 0 {
			for i, x := range fnType.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("$arg%d", i)
				}
				if i > 0 {
					fmt.Fprint(w, ", ")
				}

				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "i32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "i64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "f32_t %v", argName)
				case token.F64:
					fmt.Fprintf(w, "f64_t %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ") {\n")

		// 定义返回值
		if len(fnType.Results) > 0 {
			fmt.Fprintf(w, "  union { %s v; %s host; } ret;\n", cRetType, cHostRetType)
		}

		// 处理宿主函数调用的返回值
		if len(fnType.Results) > 0 {
			fmt.Fprintf(w, "  ret.v = host_fn_%s(", toCName(importSpec.ObjModule+"."+importSpec.ObjName))
		} else {
			fmt.Fprintf(w, "  host_fn_%s(", toCName(importSpec.ObjModule+"."+importSpec.ObjName))
		}

		// 调用参数
		for i, x := range fnType.Params {
			var argName string
			if x.Name != "" {
				argName = toCName(x.Name)
			} else {
				argName = fmt.Sprintf("$arg%d", i)
			}

			if i > 0 {
				fmt.Fprint(w, ", ")
			}
			fmt.Fprint(w, argName)
		}
		fmt.Fprintf(w, ");\n")

		// 返回结果
		if len(fnType.Results) > 0 {
			fmt.Fprintf(w, "  return ret.host;\n")
		}

		fmt.Fprintf(w, "}\n")
		fmt.Fprintln(w)
	}
	fmt.Fprintln(w)

	return nil
}

func (p *wat2cWorker) buildMemory_data(w io.Writer) error {
	fmt.Fprintf(w, "void fn_memory_init() {\n")
	defer fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "  memset(&wasm_memory[0], 0, wasm_memory_size*65536);\n")
	fmt.Fprintln(w)

	for _, d := range p.m.Data {
		var sb strings.Builder
		for _, x := range d.Value {
			sb.WriteString(fmt.Sprintf("\\x%02x", x))
		}
		fmt.Fprintf(w, "  memcpy((void*)WASM_MEMORY_ADDR(%d), (void *)(\"%s\"), %d);\n", d.Offset, sb.String(), len(d.Value))
	}
	return nil
}

func (p *wat2cWorker) buildTable_elem(w io.Writer) error {
	fmt.Fprintf(w, "void fn_table_init() {\n")
	defer fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "  memset(&wasm_table[0], 0, wasm_table_size*sizeof(wasm_table[0]));\n")
	fmt.Fprintln(w)

	for _, e := range p.m.Elem {
		for i, x := range e.Values {
			fmt.Fprintf(w, "  wasm_table[%d] = %s;\n", int(e.Offset)+i, "(ref_t)(fn_"+toCName(x)+")")
		}
	}

	return nil
}

func (p *wat2cWorker) buildMemory(w io.Writer) error {
	if p.m.Memory == nil {
		return nil
	}
	if p.m.Memory.Name != "" {
		fmt.Fprintf(w, "// memory $%s\n", p.m.Memory.Name)
	}
	if max := p.m.Memory.MaxPages; max > 0 {
		fmt.Fprintf(w, "uint8_t       wasm_memory[%d*64*1024];\n", max)
		fmt.Fprintf(w, "const int32_t wasm_memory_init_max_pages = %d;\n", max)
		fmt.Fprintf(w, "const int32_t wasm_memory_init_pages = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(w, "int32_t       wasm_memory_size = %d;\n", p.m.Memory.Pages)
	} else {
		fmt.Fprintf(w, "uint8_t       wasm_memory[%d*64*1024];\n", p.m.Memory.Pages)
		fmt.Fprintf(w, "const int32_t wasm_memory_init_max_pages = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(w, "const int32_t wasm_memory_init_pages = %d;\n", p.m.Memory.Pages)
		fmt.Fprintf(w, "int32_t       wasm_memory_size = %d;\n", p.m.Memory.Pages)
	}
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#define WASM_MEMORY_ADDR(addr) wasm_memory_addr_at((addr),__FILE__,__LINE__)\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "uint8_t* wasm_memory_addr_at(i32_t addr, const char* file, i32_t line) {\n")
	fmt.Fprintf(w, "  if(addr < 0 || addr >= wasm_memory_size*65536) {\n")
	fmt.Fprintf(w, "    printf(\"%%s:%%d addr=%%d\\n\", file, line, addr);\n")
	fmt.Fprintf(w, "    abort();\n")
	fmt.Fprintf(w, "  }\n")
	fmt.Fprintf(w, "  return &wasm_memory[addr];\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintln(w)
	return nil
}

func (p *wat2cWorker) buildTable(w io.Writer) error {
	if p.m.Table == nil {
		return nil
	}
	if p.m.Table.Type != token.FUNCREF {
		return fmt.Errorf("unsupported table type: %s", p.m.Table.Type)
	}

	if p.m.Table.Name != "" {
		fmt.Fprintf(w, "// table $%s\n", p.m.Table.Name)
	}
	if max := p.m.Table.MaxSize; max > 0 {
		fmt.Fprintf(w, "ref_t     wasm_table[%d];\n", max)
		fmt.Fprintf(w, "const int wasm_table_init_max_size = %d;\n", max)
		fmt.Fprintf(w, "int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
	} else {
		fmt.Fprintf(w, "ref_t     wasm_table[%d];\n", p.m.Table.Size)
		fmt.Fprintf(w, "const int wasm_table_init_max_size = %d;\n", p.m.Table.Size)
		fmt.Fprintf(w, "int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
	}
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#define WASM_TABLE_GET(addr) wasm_table_get((addr),__FILE__,__LINE__)\n")
	fmt.Fprintf(w, "#define WASM_TABLE_SET(addr,val) wasm_table_set((addr),(val),__FILE__,__LINE__)\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "ref_t wasm_table_get(i32_t addr, const char* file, i32_t line) {\n")
	fmt.Fprintf(w, "  if(addr < 0 || addr >= wasm_table_size) {\n")
	fmt.Fprintf(w, "    printf(\"%%s:%%d addr=%%d\\n\", file, line, addr);\n")
	fmt.Fprintf(w, "    abort();\n")
	fmt.Fprintf(w, "  }\n")
	fmt.Fprintf(w, "  return wasm_table[addr];\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintf(w, "void wasm_table_set(i32_t addr, ref_t val, const char* file, i32_t line) {\n")
	fmt.Fprintf(w, "  if(addr < 0 || addr >= wasm_table_size) {\n")
	fmt.Fprintf(w, "    printf(\"%%s:%%d addr=%%d\\n\", file, line, addr);\n")
	fmt.Fprintf(w, "    abort();\n")
	fmt.Fprintf(w, "  }\n")
	fmt.Fprintf(w, "  wasm_table[addr] = val;\n")
	fmt.Fprintf(w, "}\n")
	fmt.Fprintln(w)
	return nil
}

func (p *wat2cWorker) buildGlobal(w io.Writer) error {
	if len(p.m.Globals) == 0 {
		return nil
	}
	for _, g := range p.m.Globals {
		fmt.Fprintf(w, "// global $%s: %v\n", g.Name, g.Type)
		switch g.Type {
		case token.I32:
			if g.Mutable {
				fmt.Fprintf(w, "static i32_t var_%s = %d;\n", toCName(g.Name), g.I32Value)
			} else {
				fmt.Fprintf(w, "static const i32_t var_%s = %d;\n", toCName(g.Name), g.I32Value)
			}
		case token.I64:
			if g.Mutable {
				fmt.Fprintf(w, "static i64_t var_%s = %d;\n", toCName(g.Name), g.I64Value)
			} else {
				fmt.Fprintf(w, "static const i64_t var_%s = %d;\n", toCName(g.Name), g.I64Value)
			}
		case token.F32:
			if g.Mutable {
				fmt.Fprintf(w, "static f32_t var_%s = %f;\n", toCName(g.Name), g.F32Value)
			} else {
				fmt.Fprintf(w, "static const f32_t var_%s = %f;\n", toCName(g.Name), g.F32Value)
			}
		case token.F64:
			if g.Mutable {
				fmt.Fprintf(w, "static f64_t var_%s = %f;\n", toCName(g.Name), g.F64Value)
			} else {
				fmt.Fprintf(w, "static const f64_t var_%s = %f;\n", toCName(g.Name), g.F64Value)
			}
		default:
			return fmt.Errorf("unsupported global type: %s", g.Type)
		}
	}
	fmt.Fprintln(w)
	return nil
}

func (p *wat2cWorker) buildFuncs(w io.Writer) error {
	if len(p.m.Funcs) == 0 {
		return nil
	}

	// 函数声明
	for _, f := range p.m.Funcs {
		fmt.Fprintf(w, "// func $%s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(w, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(w, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(w, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(w, " %v", x)
			}
			fmt.Fprint(w, ")")
		}
		fmt.Fprintln(w)

		// 返回值类型
		cRetType := p.getFuncCRetType(f.Type, f.Name)
		if len(f.Type.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(f.Type.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch f.Type.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "i32_t $R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "i64_t $R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "f32_t $R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "f64_t $R%d;", i)
				}
			}
			fmt.Fprintf(w, "} fn_%s_ret_t;\n", toCName(f.Name))
		}

		fmt.Fprintf(w, "extern %s fn_%s(", cRetType, toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				switch x.Type {
				case token.I32:
					if x.Name != "" {
						fmt.Fprintf(w, "i32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "i32_t $arg%d", i)
					}
				case token.I64:
					if x.Name != "" {
						fmt.Fprintf(w, "i64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "i64_t $arg%d", i)
					}
				case token.F32:
					if x.Name != "" {
						fmt.Fprintf(w, "f32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "f32_t $arg%d", i)
					}
				case token.F64:
					if x.Name != "" {
						fmt.Fprintf(w, "f64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "f64_t $arg%d", i)
					}
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	// 函数的实现
	var funcImplBuf bytes.Buffer
	var wBackup = w

	w = &funcImplBuf
	for _, f := range p.m.Funcs {
		p.localNames = nil
		p.localTypes = nil
		p.scopeLabels = nil
		p.scopeStackBases = nil

		cRetType := p.getFuncCRetType(f.Type, f.Name)

		fmt.Fprintf(w, "// func %s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(w, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(w, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(w, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(w, " %v", x)
			}
			fmt.Fprint(w, ")")
		}
		fmt.Fprintln(w)

		// 返回值通过栈传递, 返回入栈的个数
		fmt.Fprintf(w, "%s fn_%s(", cRetType, toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("$arg%d", i)
				}

				p.localNames = append(p.localNames, argName)
				p.localTypes = append(p.localTypes, x.Type)

				if i > 0 {
					fmt.Fprint(w, ", ")
				}
				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "i32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "i64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "f32_t %v", argName)
				case token.F64:
					fmt.Fprintf(w, "f64_t %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ") {\n")
		if err := p.buildFunc_body(w, f, cRetType); err != nil {
			return err
		}
		fmt.Fprintf(w, "}\n\n")
	}

	// 恢复输出流
	w = wBackup

	// 扩展数学函数
	if p.useMathX {
		fmt.Fprintln(w, math_x_code)
	}

	// 复制函数实现
	{
		code := bytes.TrimSpace(funcImplBuf.Bytes())
		if _, err := w.Write(code); err != nil {
			return err
		}
	}

	fmt.Fprintln(w)
	return nil
}
