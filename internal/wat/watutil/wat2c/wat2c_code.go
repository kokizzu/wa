// 版权 @2024 凹语言 作者。保留所有权利。

package wat2c

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"strings"

	"wa-lang.org/wa/internal/wat/token"
)

//go:embed _math_x.c
var math_x_code string

func (p *wat2cWorker) buildCode(w io.Writer) error {
	fmt.Fprintf(w, "// Auto Generated by https://wa-lang.org/wa/wat2c. DONOT EDIT!!!\n\n")

	if p.m.Name != "" {
		fmt.Fprintf(w, "// module %s\n\n", p.m.Name)
	}

	fmt.Fprintf(w, "#include <stddef.h>\n")
	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintf(w, "#include <stdlib.h>\n")
	fmt.Fprintf(w, "#include <string.h>\n")
	fmt.Fprintf(w, "#include <math.h>\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "typedef union val_t {\n")
	fmt.Fprintf(w, "  int64_t   i64;\n")
	fmt.Fprintf(w, "  double    f64;\n")
	fmt.Fprintf(w, "  int32_t   i32;\n")
	fmt.Fprintf(w, "  float     f32;\n")
	fmt.Fprintf(w, "  uintptr_t ref;\n")
	fmt.Fprintf(w, "} val_t;\n\n")

	if err := p.buildImport(w); err != nil {
		return err
	}

	if err := p.buildMemory(w); err != nil {
		return err
	}
	if err := p.buildTable(w); err != nil {
		return err
	}

	if err := p.buildGlobal(w); err != nil {
		return err
	}
	if err := p.buildFuncs(w); err != nil {
		return err
	}

	if err := p.buildTable_elem(w); err != nil {
		return err
	}
	if err := p.buildMemory_data(w); err != nil {
		return err
	}

	// 生成 init 函数
	{
		fmt.Fprintln(w)
		fmt.Fprintf(w, "void %s_init() {\n", p.opt.Prefix)
		fmt.Fprintf(w, "  static int init_flag = 0;\n")
		fmt.Fprintf(w, "  if(init_flag) return;\n")
		fmt.Fprintf(w, "  init_flag = 1;\n")
		if p.m.Memory != nil {
			fmt.Fprintf(w, "  %s_memory_init(&%s_memory, &%s_memory_size);\n",
				p.opt.Prefix,
				p.opt.Prefix,
				p.opt.Prefix,
			)
			fmt.Fprintf(w, "  %s_memory_init_data(&%s_memory, &%s_memory_size);\n",
				p.opt.Prefix,
				p.opt.Prefix,
				p.opt.Prefix,
			)
		}
		if p.m.Table != nil {
			fmt.Fprintf(w, "  %s_table_init_elem();\n", p.opt.Prefix)
		}
		if p.m.Start != "" {
			fmt.Fprintf(w, "  %s_%s();\n", p.opt.Prefix, toCName(p.m.Start))
		}
		fmt.Fprintf(w, "  return;\n")
		fmt.Fprintf(w, "}\n")
	}

	// 生成 main 函数
	for _, fn := range p.m.Funcs {
		if fn.ExportName == "_main" {
			fmt.Fprintln(w)
			fmt.Fprintf(w, "void %s_main() {\n", p.opt.Prefix)
			fmt.Fprintf(w, "  %s__main();\n", p.opt.Prefix)
			fmt.Fprintf(w, "  return;\n")
			fmt.Fprintf(w, "}\n")
		}
	}

	return nil
}

func (p *wat2cWorker) buildImport(w io.Writer) error {
	if len(p.m.Imports) == 0 {
		return nil
	}

	// 同一个对象可能被导入多次
	var hostGlobalMap = make(map[string]bool)
	var hostFuncMap = make(map[string]bool)

	// 导入全局的只读变量
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.GLOBAL {
			continue
		}

		globalName := importSpec.ObjModule + "." + importSpec.ObjName
		globalType := importSpec.GlobalType

		// 已经处理过
		if hostGlobalMap[globalName] {
			continue
		}
		hostGlobalMap[globalName] = true

		fmt.Fprintf(w, "extern %s %s_%s;\n", p.getCType(globalType), p.opt.Prefix, toCName(globalName))
	}
	if len(hostGlobalMap) > 0 {
		fmt.Fprintln(w)
	}

	// 声明原始的宿主函数
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.FUNC {
			continue
		}

		fnName := importSpec.ObjModule + "." + importSpec.ObjName
		fnType := importSpec.FuncType

		// 已经处理过
		if hostFuncMap[fnName] {
			continue
		}
		hostFuncMap[fnName] = true

		// 返回值类型
		cRetType := p.getHostFuncCRetType(fnType)
		if len(fnType.Results) > 1 {
			panic("wat2c: host func donot support multi return value")
		}

		// 返回值通过栈传递
		fmt.Fprintf(w, "extern %s %s_%s(", cRetType, p.opt.Prefix, toCName(fnName))
		if len(fnType.Params) > 0 {
			for i, x := range fnType.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("arg%d", i)
				}
				if i > 0 {
					fmt.Fprint(w, ", ")
				}

				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "int32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "int64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "float %v", argName)
				case token.F64:
					fmt.Fprintf(w, "double %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	if len(hostFuncMap) > 0 {
		fmt.Fprintln(w)
	}

	// 定义导入后的全局变量
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.GLOBAL {
			continue
		}

		fmt.Fprintf(w, "#define %s_%s %s_%s // import %s.%s\n",
			p.opt.Prefix, toCName(importSpec.GlobalName),
			p.opt.Prefix, toCName(importSpec.ObjModule+"."+importSpec.ObjName),
			importSpec.ObjModule, importSpec.ObjName,
		)
	}
	if len(hostGlobalMap) > 0 {
		fmt.Fprintln(w)
	}

	// 定义导入后的函数
	for _, importSpec := range p.m.Imports {
		if importSpec.ObjKind != token.FUNC {
			continue
		}

		fmt.Fprintf(w, "#define %s_%s %s_%s // import %s.%s\n",
			p.opt.Prefix, toCName(importSpec.FuncName),
			p.opt.Prefix, toCName(importSpec.ObjModule+"."+importSpec.ObjName),
			importSpec.ObjModule, importSpec.ObjName,
		)
	}
	if len(hostFuncMap) > 0 {
		fmt.Fprintln(w)
	}

	return nil
}

func (p *wat2cWorker) buildMemory_data(w io.Writer) error {
	if p.m.Memory == nil {
		return nil
	}

	fmt.Fprintf(w, "\nstatic void %s_memory_init_data() {\n", p.opt.Prefix)
	defer fmt.Fprintf(w, "}\n\n")

	// C 语言中 \x 转义序列是“贪婪”的, 会一直读取尽可能多的十六进制字符作为转义值的一部分，不会自动终止。
	// 因此 \x000a 会被解析为 \x0a, 而不是 \x00 和 "0a" 字符串
	// 解决的办法是通过字符串强制切割: \x00""0a

	prevIsHexEscape := false

	for _, d := range p.m.Data {
		var sb strings.Builder
		for _, x := range d.Value {
			switch {
			case x == 0:
				// \0 也会遇到 \00 类似的歧义问题, 统一用 \x00 表示
				prevIsHexEscape = true
				sb.WriteString("\\x00")
			case '0' <= x && x <= '9':
				if prevIsHexEscape {
					// 数字都可能被前面的 \x... 吸收
					sb.WriteString(`""`)
				}
				prevIsHexEscape = false
				sb.WriteString(fmt.Sprintf("%c", x))
			case 'a' <= x && x <= 'z':
				if prevIsHexEscape && x <= 'f' {
					// 部分字母可能被前面的 \x... 吸收
					sb.WriteString(`""`)
				}
				prevIsHexEscape = false
				sb.WriteString(fmt.Sprintf("%c", x))
			case 'A' <= x && x <= 'Z':
				if prevIsHexEscape && x <= 'F' {
					// 部分字母可能被前面的 \x... 吸收
					sb.WriteString(`""`)
				}
				prevIsHexEscape = false
				sb.WriteString(fmt.Sprintf("%c", x))
			case strings.ContainsRune(" `~!@#$%^&*()_-+={}[]|:;'<>,.?/", rune(x)):
				prevIsHexEscape = false
				sb.WriteString(fmt.Sprintf("%c", x))
			case x == '"':
				prevIsHexEscape = false
				sb.WriteString("\\\"")
			case x == '\t':
				prevIsHexEscape = false
				sb.WriteString("\\t")
			case x == '\n':
				prevIsHexEscape = false
				sb.WriteString("\\n")
			case x == '\\':
				prevIsHexEscape = false
				sb.WriteString("\\")
			case x == ' ':
				prevIsHexEscape = false
				sb.WriteString(" ")
			default:
				prevIsHexEscape = true
				sb.WriteString(fmt.Sprintf("\\x%02x", x))
			}
		}
		fmt.Fprintf(w, "  memcpy((void*)(&%s_memory[%d]), (void *)(\"%s\"), %d);\n",
			p.opt.Prefix, d.Offset, sb.String(), len(d.Value),
		)
	}
	return nil
}

func (p *wat2cWorker) buildTable_elem(w io.Writer) error {
	if p.m.Table == nil {
		return nil
	}
	fmt.Fprintf(w, "void %s_table_init_elem() {\n", p.opt.Prefix)
	defer fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "  memset(&%[1]s_table[0], 0, %[1]s_table_size*sizeof(%[1]s_table[0]));\n",
		p.opt.Prefix,
	)
	fmt.Fprintln(w)

	for _, e := range p.m.Elem {
		for i, x := range e.Values {
			val := fmt.Sprintf("(uintptr_t)(%s_%s)", p.opt.Prefix, toCName(x))
			fmt.Fprintf(w, "  %s_table[%d] = %s;\n", p.opt.Prefix, int(e.Offset)+i, val)
		}
	}

	return nil
}

func (p *wat2cWorker) buildMemory(w io.Writer) error {
	if p.m.Memory == nil {
		return nil
	}
	if p.m.Memory.Name != "" {
		fmt.Fprintf(w, "// memory $%s\n", p.m.Memory.Name)
	}
	if max := p.m.Memory.MaxPages; max > 0 {
		fmt.Fprintf(w, "uint8_t*      %s_memory = NULL;\n", p.opt.Prefix)
		fmt.Fprintf(w, "const int32_t %s_memory_init_max_pages = %d;\n", p.opt.Prefix, max)
		fmt.Fprintf(w, "const int32_t %s_memory_init_pages = %d;\n", p.opt.Prefix, p.m.Memory.Pages)
		fmt.Fprintf(w, "int32_t       %s_memory_size = %d;\n", p.opt.Prefix, 0)
	} else {
		fmt.Fprintf(w, "uint8_t*      %s_memory = NULL;\n", p.opt.Prefix)
		fmt.Fprintf(w, "const int32_t %s_memory_init_max_pages = %d;\n", p.opt.Prefix, p.m.Memory.Pages)
		fmt.Fprintf(w, "const int32_t %s_memory_init_pages = %d;\n", p.opt.Prefix, p.m.Memory.Pages)
		fmt.Fprintf(w, "int32_t       %s_memory_size = %d;\n", p.opt.Prefix, 0)
	}
	fmt.Fprintln(w)

	return nil
}

func (p *wat2cWorker) buildTable(w io.Writer) error {
	if p.m.Table == nil {
		return nil
	}
	if p.m.Table.Type != token.FUNCREF {
		return fmt.Errorf("unsupported table type: %s", p.m.Table.Type)
	}

	if p.m.Table.Name != "" {
		fmt.Fprintf(w, "// table $%s\n", p.m.Table.Name)
	}
	if max := p.m.Table.MaxSize; max > 0 {
		fmt.Fprintf(w, "uintptr_t %s_table[%d];\n", p.opt.Prefix, max)
		fmt.Fprintf(w, "const int %s_table_init_max_size = %d;\n", p.opt.Prefix, max)
		fmt.Fprintf(w, "int32_t   %s_table_size = %d;\n", p.opt.Prefix, p.m.Table.Size)
	} else {
		fmt.Fprintf(w, "uintptr_t %s_table[%d];\n", p.opt.Prefix, p.m.Table.Size)
		fmt.Fprintf(w, "const int %s_table_init_max_size = %d;\n", p.opt.Prefix, p.m.Table.Size)
		fmt.Fprintf(w, "int32_t   %s_table_size = %d;\n", p.opt.Prefix, p.m.Table.Size)
	}
	fmt.Fprintln(w)

	return nil
}

func (p *wat2cWorker) buildGlobal(w io.Writer) error {
	if len(p.m.Globals) == 0 {
		return nil
	}
	for _, g := range p.m.Globals {
		fmt.Fprintf(w, "// global $%s: %v\n", g.Name, g.Type)
		switch g.Type {
		case token.I32:
			if g.Mutable {
				fmt.Fprintf(w, "static int32_t %s_%s = %d;\n", p.opt.Prefix, toCName(g.Name), g.I32Value)
			} else {
				fmt.Fprintf(w, "static const int32_t %s_%s = %d;\n", p.opt.Prefix, toCName(g.Name), g.I32Value)
			}
		case token.I64:
			if g.Mutable {
				fmt.Fprintf(w, "static int64_t %s_%s = %d;\n", p.opt.Prefix, toCName(g.Name), g.I64Value)
			} else {
				fmt.Fprintf(w, "static const int64_t %s_%s = %d;\n", p.opt.Prefix, toCName(g.Name), g.I64Value)
			}
		case token.F32:
			if g.Mutable {
				fmt.Fprintf(w, "static float %s_%s = %f;\n", p.opt.Prefix, toCName(g.Name), g.F32Value)
			} else {
				fmt.Fprintf(w, "static const float %s_%s = %f;\n", p.opt.Prefix, toCName(g.Name), g.F32Value)
			}
		case token.F64:
			if g.Mutable {
				fmt.Fprintf(w, "static double %s_%s = %f;\n", p.opt.Prefix, toCName(g.Name), g.F64Value)
			} else {
				fmt.Fprintf(w, "static const double %s_%s = %f;\n", p.opt.Prefix, toCName(g.Name), g.F64Value)
			}
		default:
			return fmt.Errorf("unsupported global type: %s", g.Type)
		}
	}
	fmt.Fprintln(w)
	return nil
}

func (p *wat2cWorker) buildFuncs(w io.Writer) error {
	if len(p.m.Funcs) == 0 {
		return nil
	}

	// 函数声明
	for _, f := range p.m.Funcs {
		fmt.Fprintf(w, "// func $%s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(w, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(w, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(w, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(w, " %v", x)
			}
			fmt.Fprint(w, ")")
		}
		fmt.Fprintln(w)

		// 返回值类型
		cRetType := p.getFuncCRetType(f.Type, f.Name)
		if len(f.Type.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(f.Type.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch f.Type.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "int32_t R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "int64_t R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "float R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "double R%d;", i)
				}
			}
			fmt.Fprintf(w, "} %s_%s_ret_t;\n", p.opt.Prefix, toCName(f.Name))
		}

		if f.ExportName == "" {
			fmt.Fprintf(w, "static %s %s_%s(", cRetType, p.opt.Prefix, toCName(f.Name))
		} else {
			fmt.Fprintf(w, "extern %s %s_%s(", cRetType, p.opt.Prefix, toCName(f.Name))
		}
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				switch x.Type {
				case token.I32:
					if x.Name != "" {
						fmt.Fprintf(w, "int32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "int32_t arg%d", i)
					}
				case token.I64:
					if x.Name != "" {
						fmt.Fprintf(w, "int64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "int64_t arg%d", i)
					}
				case token.F32:
					if x.Name != "" {
						fmt.Fprintf(w, "float %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "float arg%d", i)
					}
				case token.F64:
					if x.Name != "" {
						fmt.Fprintf(w, "double %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "double arg%d", i)
					}
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	// 函数的实现
	var funcImplBuf bytes.Buffer
	var wBackup = w

	w = &funcImplBuf
	for _, f := range p.m.Funcs {
		p.localNames = nil
		p.localTypes = nil
		p.scopeLabels = nil
		p.scopeStackBases = nil
		p.scopeResults = nil

		cRetType := p.getFuncCRetType(f.Type, f.Name)

		fmt.Fprintf(w, "// func %s", f.Name)
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if x.Name != "" {
					fmt.Fprintf(w, " (param $%s %v)", x.Name, x.Type)
				} else {
					fmt.Fprintf(w, " (param $%d %v)", i, x.Type)
				}
			}
		}
		if len(f.Type.Results) > 0 {
			fmt.Fprintf(w, " (result")
			for _, x := range f.Type.Results {
				fmt.Fprintf(w, " %v", x)
			}
			fmt.Fprint(w, ")")
		}
		fmt.Fprintln(w)

		// 返回值通过栈传递, 返回入栈的个数
		if f.ExportName == "" {
			fmt.Fprintf(w, "static %s %s_%s(", cRetType, p.opt.Prefix, toCName(f.Name))
		} else {
			fmt.Fprintf(w, "%s %s_%s(", cRetType, p.opt.Prefix, toCName(f.Name))
		}
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				var argName string
				if x.Name != "" {
					argName = toCName(x.Name)
				} else {
					argName = fmt.Sprintf("arg%d", i)
				}

				p.localNames = append(p.localNames, argName)
				p.localTypes = append(p.localTypes, x.Type)

				if i > 0 {
					fmt.Fprint(w, ", ")
				}
				switch x.Type {
				case token.I32:
					fmt.Fprintf(w, "int32_t %v", argName)
				case token.I64:
					fmt.Fprintf(w, "int64_t %v", argName)
				case token.F32:
					fmt.Fprintf(w, "float %v", argName)
				case token.F64:
					fmt.Fprintf(w, "double %v", argName)
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ") {\n")
		if err := p.buildFunc_body(w, f, cRetType); err != nil {
			return err
		}
		fmt.Fprintf(w, "}\n\n")
	}

	// 恢复输出流
	w = wBackup

	// 扩展数学函数
	if p.useMathX {
		fmt.Fprintln(w, math_x_code)
	}

	// 复制函数实现
	{
		code := bytes.TrimSpace(funcImplBuf.Bytes())
		if _, err := w.Write(code); err != nil {
			return err
		}
	}

	fmt.Fprintln(w)
	return nil
}
