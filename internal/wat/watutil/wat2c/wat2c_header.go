// 版权 @2024 凹语言 作者。保留所有权利。

package wat2c

import (
	"fmt"
	"io"

	"wa-lang.org/wa/internal/wat/ast"
	"wa-lang.org/wa/internal/wat/token"
)

func (p *wat2cWorker) buildHeader(w io.Writer) error {
	fmt.Fprintf(w, "// Auto Generated by https://wa-lang.org/wa/wat2c. DONOT EDIT!!!\n\n")

	if p.m.Name != "" {
		fmt.Fprintf(w, "// module %s\n\n", p.m.Name)
	}

	fmt.Fprintf(w, "#pragma once\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "typedef uint8_t   u8_t;\n")
	fmt.Fprintf(w, "typedef int8_t    i8_t;\n")
	fmt.Fprintf(w, "typedef uint16_t  u16_t;\n")
	fmt.Fprintf(w, "typedef int16_t   i16_t;\n")
	fmt.Fprintf(w, "typedef uint32_t  u32_t;\n")
	fmt.Fprintf(w, "typedef int32_t   i32_t;\n")
	fmt.Fprintf(w, "typedef uint64_t  u64_t;\n")
	fmt.Fprintf(w, "typedef int64_t   i64_t;\n")
	fmt.Fprintf(w, "typedef float     f32_t;\n")
	fmt.Fprintf(w, "typedef double    f64_t;\n")
	fmt.Fprintf(w, "typedef uintptr_t ref_t;\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "typedef union val_t {\n")
	fmt.Fprintf(w, "  i64_t i64;\n")
	fmt.Fprintf(w, "  f64_t f64;\n")
	fmt.Fprintf(w, "  i32_t i32;\n")
	fmt.Fprintf(w, "  f32_t f32;\n")
	fmt.Fprintf(w, "  ref_t ref;\n")
	fmt.Fprintf(w, "} val_t;\n\n")

	if p.m.Memory != nil {
		if p.m.Memory.Name != "" {
			fmt.Fprintf(w, "// memory $%s\n", p.m.Memory.Name)
		}
		if max := p.m.Memory.MaxPages; max > 0 {
			fmt.Fprintf(w, "extern uint8_t       wasm_memory[%d*64*1024];\n", max)
			fmt.Fprintf(w, "extern const int32_t wasm_memory_init_max_pages = %d;\n", max)
			fmt.Fprintf(w, "extern const int32_t wasm_memory_init_pages = %d;\n", p.m.Memory.Pages)
			fmt.Fprintf(w, "extern int32_t       wasm_memory_size = %d;\n", p.m.Memory.Pages)
		} else {
			fmt.Fprintf(w, "extern uint8_t       wasm_memory[%d*64*1024];\n", p.m.Memory.Pages)
			fmt.Fprintf(w, "extern const int32_t wasm_memory_init_max_pages = %d;\n", p.m.Memory.Pages)
			fmt.Fprintf(w, "extern const int32_t wasm_memory_init_pages = %d;\n", p.m.Memory.Pages)
			fmt.Fprintf(w, "extern int32_t       wasm_memory_size = %d;\n", p.m.Memory.Pages)
		}
		fmt.Fprintln(w)
	}
	if p.m.Table != nil {
		if p.m.Table.Name != "" {
			fmt.Fprintf(w, "// table $%s\n", p.m.Table.Name)
		}
		if max := p.m.Table.MaxSize; max > 0 {
			fmt.Fprintf(w, "extern ref_t     wasm_table[%d];\n", max)
			fmt.Fprintf(w, "extern const int wasm_table_init_max_size = %d;\n", max)
			fmt.Fprintf(w, "extern int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
		} else {
			fmt.Fprintf(w, "extern ref_t     wasm_table[%d];\n", p.m.Table.Size)
			fmt.Fprintf(w, "extern const int wasm_table_init_max_size = %d;\n", p.m.Table.Size)
			fmt.Fprintf(w, "extern int32_t   wasm_table_size = %d;\n", p.m.Table.Size)
		}
		fmt.Fprintln(w)
	}

	fmt.Fprintf(w, "extern uint8_t* wasm_memory_addr_at(i32_t idx, const char* file, i32_t line);\n")
	fmt.Fprintln(w)

	if len(p.m.Exports) == 0 {
		return nil
	}
	var exportFuncMap = make(map[string]*ast.ExportSpec)
	for _, e := range p.m.Exports {
		switch e.Kind {
		case token.FUNC:
			exportFuncMap[e.Name] = e
		}
	}
	if len(exportFuncMap) == 0 {
		return nil
	}

	for _, f := range p.m.Funcs {
		if f.ExportName == "" {
			continue
		}

		fmt.Fprintf(w, "// func $%s\n", f.Name)

		// 返回值类型
		cRetType := p.getFuncCRetType(f.Type, f.Name)
		if len(f.Type.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(f.Type.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch f.Type.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "i32_t $R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "i64_t $R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "f32_t $R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "f64_t $R%d;", i)
				}
			}
			fmt.Fprintf(w, "} fn_%s_ret_t;\n", toCName(f.Name))
		}

		fmt.Fprintf(w, "extern %s fn_%s(", cRetType, toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				switch x.Type {
				case token.I32:
					if x.Name != "" {
						fmt.Fprintf(w, "i32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "i32_t $arg%d", i)
					}
				case token.I64:
					if x.Name != "" {
						fmt.Fprintf(w, "i64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "i64_t $arg%d", i)
					}
				case token.F32:
					if x.Name != "" {
						fmt.Fprintf(w, "f32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "f32_t $arg%d", i)
					}
				case token.F64:
					if x.Name != "" {
						fmt.Fprintf(w, "f64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "f64_t $arg%d", i)
					}
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	return nil
}
