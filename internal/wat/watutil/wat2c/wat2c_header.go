// 版权 @2024 凹语言 作者。保留所有权利。

package wat2c

import (
	"fmt"
	"io"

	"wa-lang.org/wa/internal/wat/ast"
	"wa-lang.org/wa/internal/wat/token"
)

func (p *wat2cWorker) buildHeader(w io.Writer) error {
	fmt.Fprintf(w, "// Auto Generated by https://wa-lang.org/wa/wat2c. DONOT EDIT!!!\n\n")

	if p.m.Name != "" {
		fmt.Fprintf(w, "// module %s\n\n", p.m.Name)
	}

	fmt.Fprintf(w, "#pragma once\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#ifndef _%s_H_\n", p.prefix)
	fmt.Fprintf(w, "#define _%s_H_\n", p.prefix)
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#ifdef __cplusplus\n")
	fmt.Fprintf(w, "extern \"C\" {\n")
	fmt.Fprintf(w, "#endif\n")
	fmt.Fprintln(w)

	if p.m.Memory != nil {
		if p.m.Memory.Name != "" {
			fmt.Fprintf(w, "// memory $%s\n", p.m.Memory.Name)
		}
		if max := p.m.Memory.MaxPages; max > 0 {
			fmt.Fprintf(w, "extern uint8_t*      %s_memory;\n", p.prefix)
			fmt.Fprintf(w, "extern const int32_t %s_memory_init_max_pages; // = %d;\n", p.prefix, max)
			fmt.Fprintf(w, "extern const int32_t %s_memory_init_pages; // = %d;\n", p.prefix, p.m.Memory.Pages)
			fmt.Fprintf(w, "extern int32_t       %s_memory_size; // = %d;\n", p.prefix, p.m.Memory.Pages)
		} else {
			fmt.Fprintf(w, "extern uint8_t*      %s_memory;\n", p.prefix)
			fmt.Fprintf(w, "extern const int32_t %s_memory_init_max_pages; // = %d;\n", p.prefix, p.m.Memory.Pages)
			fmt.Fprintf(w, "extern const int32_t %s_memory_init_pages; // = %d;\n", p.prefix, p.m.Memory.Pages)
			fmt.Fprintf(w, "extern int32_t       %s_memory_size; // = %d;\n", p.prefix, p.m.Memory.Pages)
		}
		fmt.Fprintln(w)
	}
	if p.m.Table != nil {
		if p.m.Table.Name != "" {
			fmt.Fprintf(w, "// table $%s\n", p.m.Table.Name)
		}
		if max := p.m.Table.MaxSize; max > 0 {
			fmt.Fprintf(w, "extern uintptr_t %s_table[/*%d*/];\n", p.prefix, max)
			fmt.Fprintf(w, "extern const int %s_table_init_max_size; // = %d;\n", p.prefix, max)
			fmt.Fprintf(w, "extern int32_t   %s_table_size; // = %d;\n", p.prefix, p.m.Table.Size)
		} else {
			fmt.Fprintf(w, "extern uintptr_t %s_table[/*%d*/];\n", p.prefix, p.m.Table.Size)
			fmt.Fprintf(w, "extern const int %s_table_init_max_size; // = %d;\n", p.prefix, p.m.Table.Size)
			fmt.Fprintf(w, "extern int32_t   %s_table_size; // = %d;\n", p.prefix, p.m.Table.Size)
		}
		fmt.Fprintln(w)
	}

	fmt.Fprintf(w, "extern void %s_init();\n", p.prefix)
	fmt.Fprintln(w)

	if len(p.m.Exports) == 0 {
		return nil
	}
	var exportFuncMap = make(map[string]*ast.ExportSpec)
	for _, e := range p.m.Exports {
		switch e.Kind {
		case token.FUNC:
			exportFuncMap[e.Name] = e
		}
	}
	if len(exportFuncMap) == 0 {
		return nil
	}

	for _, f := range p.m.Funcs {
		if f.ExportName == "" {
			continue
		}

		fmt.Fprintf(w, "// func $%s\n", f.Name)

		if f.ExportName != f.Name {
			fmt.Fprintf(w, "#define %s_%s %s_%s\n",
				p.prefix, toCName(f.ExportName),
				p.prefix, toCName(f.Name),
			)
		}

		// 返回值类型
		cRetType := p.getFuncCRetType(f.Type, f.Name)
		if len(f.Type.Results) > 1 {
			fmt.Fprintf(w, "typedef struct {")
			for i := 0; i < len(f.Type.Results); i++ {
				if i > 0 {
					fmt.Fprintf(w, " ")
				}
				switch f.Type.Results[i] {
				case token.I32:
					fmt.Fprintf(w, "int32_t R%d;", i)
				case token.I64:
					fmt.Fprintf(w, "int64_t R%d;", i)
				case token.F32:
					fmt.Fprintf(w, "float R%d;", i)
				case token.F64:
					fmt.Fprintf(w, "double R%d;", i)
				}
			}
			fmt.Fprintf(w, "} %s_%s_ret_t;\n", p.prefix, toCName(f.Name))
		}

		fmt.Fprintf(w, "extern %s %s_%s(", cRetType, p.prefix, toCName(f.Name))
		if len(f.Type.Params) > 0 {
			for i, x := range f.Type.Params {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				switch x.Type {
				case token.I32:
					if x.Name != "" {
						fmt.Fprintf(w, "int32_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "int32_t arg%d", i)
					}
				case token.I64:
					if x.Name != "" {
						fmt.Fprintf(w, "int64_t %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "int64_t arg%d", i)
					}
				case token.F32:
					if x.Name != "" {
						fmt.Fprintf(w, "float %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "float arg%d", i)
					}
				case token.F64:
					if x.Name != "" {
						fmt.Fprintf(w, "double %v", toCName(x.Name))
					} else {
						fmt.Fprintf(w, "double arg%d", i)
					}
				default:
					unreachable()
				}
			}
		}
		fmt.Fprintf(w, ");\n")
	}
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#ifdef __cplusplus\n")
	fmt.Fprintf(w, "} // extern C \n")
	fmt.Fprintf(w, "#endif\n")
	fmt.Fprintln(w)

	fmt.Fprintf(w, "#endif // _%s_H_\n", p.prefix)

	return nil
}
